<!DOCTYPE html>
<html lang="no">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>FM Radio</title>
	<link rel="stylesheet" href="css/style.css">
	<style>
		/* Sweep Scanner Styles */
		.sweep-controls {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}
		
		.sweep-btn-row {
			display: flex;
			gap: 8px;
		}
		
		.sweep-btn {
			flex: 1;
			padding: 14px 16px;
			font-size: 16px;
			font-weight: 600;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.2s;
		}
		
		.sweep-btn-start {
			background: linear-gradient(135deg, #4CAF50, #45a049);
			color: white;
		}
		
		.sweep-btn-start:hover {
			background: linear-gradient(135deg, #45a049, #3d8b40);
		}
		
		.sweep-btn-start.sweeping {
			background: linear-gradient(135deg, #ff9800, #f57c00);
		}
		
		.sweep-btn-mark {
			background: linear-gradient(135deg, #2196F3, #1976D2);
			color: white;
			font-size: 18px;
		}
		
		.sweep-btn-mark:hover {
			background: linear-gradient(135deg, #1976D2, #1565C0);
		}
		
		.sweep-btn-mark:disabled {
			background: #ccc;
			cursor: not-allowed;
		}
		
		.sweep-btn-mark.marked {
			background: linear-gradient(135deg, #4CAF50, #45a049);
			animation: pulse-mark 0.3s ease;
		}
		
		@keyframes pulse-mark {
			0% { transform: scale(1); }
			50% { transform: scale(1.05); }
			100% { transform: scale(1); }
		}
		
		.sweep-btn-finetune {
			background: linear-gradient(135deg, #9C27B0, #7B1FA2);
			color: white;
		}
		
		.sweep-btn-finetune:hover {
			background: linear-gradient(135deg, #7B1FA2, #6A1B9A);
		}
		
		.sweep-btn-finetune:disabled {
			background: #ccc;
			cursor: not-allowed;
		}
		
		.sweep-progress {
			margin-top: 8px;
		}
		
		.sweep-progress-bar-container {
			height: 24px;
			background: #e0e0e0;
			border-radius: 12px;
			overflow: hidden;
			position: relative;
		}
		
		.sweep-progress-bar {
			height: 100%;
			background: linear-gradient(90deg, #4CAF50, #8BC34A);
			transition: width 0.3s ease;
			border-radius: 12px;
		}
		
		.sweep-progress-text {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-weight: 600;
			color: #333;
			font-size: 14px;
		}
		
		.sweep-status {
			text-align: center;
			color: #666;
			font-size: 14px;
			margin-top: 8px;
		}
		
		.sweep-speed-control {
			display: flex;
			align-items: center;
			gap: 12px;
			margin-top: 8px;
		}
		
		.sweep-speed-control label {
			font-size: 14px;
			color: #666;
		}
		
		.sweep-speed-control input[type="range"] {
			flex: 1;
		}
		
		.sweep-speed-value {
			font-size: 14px;
			font-weight: 600;
			min-width: 50px;
		}
		
		/* Marked Stations */
		.marked-stations {
			margin-top: 16px;
		}
		
		.marked-stations-title {
			font-size: 14px;
			color: #666;
			margin-bottom: 8px;
			display: flex;
			justify-content: space-between;
			align-items: center;
		}
		
		.marked-stations-title button {
			font-size: 12px;
			padding: 4px 8px;
			background: #f44336;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
		}
		
		.marked-list {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
		}
		
		.marked-item {
			background: linear-gradient(135deg, #e3f2fd, #bbdefb);
			border: 2px solid #2196F3;
			border-radius: 8px;
			padding: 8px 12px;
			cursor: pointer;
			transition: all 0.2s;
			position: relative;
		}
		
		.marked-item:hover {
			background: linear-gradient(135deg, #bbdefb, #90caf9);
		}
		
		.marked-item.tuned {
			background: linear-gradient(135deg, #9C27B0, #7B1FA2);
			color: white;
			border-color: #9C27B0;
		}
		
		.marked-item .freq {
			font-weight: 600;
			font-size: 16px;
		}
		
		.marked-item .signal {
			font-size: 12px;
			opacity: 0.8;
		}
		
		.marked-item .remove-mark {
			position: absolute;
			top: -6px;
			right: -6px;
			width: 18px;
			height: 18px;
			background: #f44336;
			color: white;
			border: none;
			border-radius: 50%;
			font-size: 12px;
			cursor: pointer;
			display: none;
			align-items: center;
			justify-content: center;
			line-height: 1;
		}
		
		.marked-item:hover .remove-mark {
			display: flex;
		}
		
		.no-marks {
			color: #999;
			font-style: italic;
			font-size: 14px;
		}
		
		/* Fine-tuning results */
		.finetune-results {
			margin-top: 16px;
			padding: 12px;
			background: #f5f5f5;
			border-radius: 8px;
		}
		
		.finetune-results-title {
			font-size: 14px;
			font-weight: 600;
			margin-bottom: 8px;
		}
	</style>
</head>
<body>
	<a href="index.html" class="back-btn">‚Üê Tilbake</a>

	<div class="header">
		<h1>üìª FM Radio</h1>
		<p class="subtitle">87.5 - 108 MHz</p>
	</div>

	<!-- Frequency Display -->
	<div class="card frequency-display">
		<div>
			<span class="frequency-value" id="freq-display">---</span>
			<span class="frequency-unit">MHz</span>
		</div>
		<div class="signal-meter">
			<div class="signal-bar-container">
				<div class="signal-bar" id="signal-bar" style="width: 0%"></div>
			</div>
			<div class="signal-value">Signal: <span id="signal-value">0</span></div>
		</div>
	</div>

	<!-- Tuning Controls -->
	<div class="card">
		<div class="card-title">Finjustering</div>
		<div class="tuning-controls">
			<div class="tune-btn-group">
				<button class="tune-btn" data-tune="-1">-1</button>
				<button class="tune-btn" data-tune="-0.5">-0.5</button>
				<button class="tune-btn" data-tune="-0.1">-0.1</button>
			</div>
			<div class="tune-btn-group">
				<button class="tune-btn" data-tune="0.1">+0.1</button>
				<button class="tune-btn" data-tune="0.5">+0.5</button>
				<button class="tune-btn" data-tune="1">+1</button>
			</div>
		</div>
		<div class="freq-input-group">
			<input type="text" class="freq-input" id="freq-input" placeholder="F.eks. 99.5M">
			<button class="set-btn" id="set-freq-btn">Sett</button>
		</div>
	</div>

	<!-- Sweep Scanner -->
	<div class="card">
		<div class="card-title">üîç Sweep Scanner</div>
		<p style="font-size: 13px; color: #666; margin-bottom: 12px;">
			Lytt mens scanneren g√•r gjennom b√•ndet. Trykk "Marker" n√•r du h√∏rer en stasjon.
		</p>
		
		<div class="sweep-controls">
			<div class="sweep-btn-row">
				<button class="sweep-btn sweep-btn-start" id="sweep-start-btn">‚ñ∂Ô∏è Start Sweep</button>
				<button class="sweep-btn sweep-btn-mark" id="sweep-mark-btn" disabled>‚≠ê Marker</button>
			</div>
			
			<div class="sweep-progress">
				<div class="sweep-progress-bar-container">
					<div class="sweep-progress-bar" id="sweep-progress-bar" style="width: 0%"></div>
					<span class="sweep-progress-text" id="sweep-progress-text">87.5 MHz</span>
				</div>
			</div>
			
			<div class="sweep-status" id="sweep-status">Klar til √• skanne</div>
			
			<div class="sweep-speed-control">
				<label>Hastighet:</label>
				<input type="range" id="sweep-speed" min="300" max="2000" value="800" step="100">
				<span class="sweep-speed-value" id="sweep-speed-value">0.8s</span>
			</div>
		</div>
		
		<!-- Marked Stations -->
		<div class="marked-stations">
			<div class="marked-stations-title">
				<span>Markerte frekvenser (<span id="marked-count">0</span>)</span>
				<button id="clear-marks-btn" style="display: none;">T√∏m alle</button>
			</div>
			<div class="marked-list" id="marked-list">
				<span class="no-marks">Ingen markeringer enn√•</span>
			</div>
		</div>
		
		<!-- Fine-tune button -->
		<div style="margin-top: 16px;">
			<button class="sweep-btn sweep-btn-finetune" id="finetune-btn" disabled>
				üéØ Finjuster markerte stasjoner
			</button>
		</div>
	</div>

	<!-- Settings -->
	<div class="card">
		<div class="card-title">Innstillinger</div>
		<div class="settings-row">
			<div class="setting-group">
				<label>Modulasjon</label>
				<select id="mod-select">
					<option value="w">WBFM (Stereo)</option>
					<option value="f">FM (Mono)</option>
				</select>
			</div>
			<div class="setting-group">
				<label>Forsterkning</label>
				<select id="gain-select">
					<option value="auto">Auto</option>
				</select>
			</div>
		</div>
		<div class="checkbox-group">
			<input type="checkbox" id="autogain-check" checked>
			<label for="autogain-check">Automatisk forsterkning</label>
		</div>
	</div>

	<!-- Audio Player -->
	<div class="audio-player">
		<div class="player-controls">
			<button class="player-btn player-btn-play" id="player-btn-play">‚ñ∂Ô∏è Start lytting</button>
			<button class="player-btn player-btn-live" id="player-btn-live"><span class="live-dot"></span> Direkte</button>
		</div>
		<div class="player-status" id="player-status">Trykk Start for √• lytte</div>
		<audio id="audio-player" preload="none">
			<source src="/stream.mp3" type="audio/mpeg">
		</audio>
	</div>

	<script>
	/**
	 * FM Sweep Scanner - Hybrid Manual/Auto Station Finding
	 */
	(function() {
		'use strict';

		// State
		let state = {
			freq_i: 0,
			freq_s: '---',
			s_level: 0,
			mod: 'w',
			gain: 0,
			autogain: true
		};
		let gains = [];
		let pollInterval = null;
		
		// Sweep scanner state
		let sweepRunning = false;
		let sweepAbort = false;
		let currentSweepFreq = 87.5;
		let markedStations = [];  // Array of {freq, signal, timestamp}
		let sweepHistory = [];    // Last N frequencies for latency compensation

		// DOM Elements
		let elements = {};

		document.addEventListener('DOMContentLoaded', init);

		function init() {
			elements = {
				freqDisplay: document.getElementById('freq-display'),
				freqInput: document.getElementById('freq-input'),
				signalBar: document.getElementById('signal-bar'),
				signalValue: document.getElementById('signal-value'),
				modSelect: document.getElementById('mod-select'),
				gainSelect: document.getElementById('gain-select'),
				autogainCheck: document.getElementById('autogain-check'),
				audioPlayer: document.getElementById('audio-player'),
				playBtn: document.getElementById('player-btn-play'),
				liveBtn: document.getElementById('player-btn-live'),
				playerStatus: document.getElementById('player-status'),
				// Sweep elements
				sweepStartBtn: document.getElementById('sweep-start-btn'),
				sweepMarkBtn: document.getElementById('sweep-mark-btn'),
				sweepProgressBar: document.getElementById('sweep-progress-bar'),
				sweepProgressText: document.getElementById('sweep-progress-text'),
				sweepStatus: document.getElementById('sweep-status'),
				sweepSpeed: document.getElementById('sweep-speed'),
				sweepSpeedValue: document.getElementById('sweep-speed-value'),
				markedList: document.getElementById('marked-list'),
				markedCount: document.getElementById('marked-count'),
				clearMarksBtn: document.getElementById('clear-marks-btn'),
				finetuneBtn: document.getElementById('finetune-btn')
			};

			setupEventListeners();
			setupSweepScanner();
			setupAudioPlayer();
			fetchGainList();
			fetchState();
			pollInterval = setInterval(fetchState, 500);
		}

		// ============ SWEEP SCANNER ============
		
		function setupSweepScanner() {
			// Start/Stop button
			elements.sweepStartBtn.addEventListener('click', toggleSweep);
			
			// Mark button
			elements.sweepMarkBtn.addEventListener('click', markCurrentFrequency);
			
			// Speed slider
			elements.sweepSpeed.addEventListener('input', updateSpeedDisplay);
			updateSpeedDisplay();
			
			// Clear marks
			elements.clearMarksBtn.addEventListener('click', clearAllMarks);
			
			// Fine-tune button
			elements.finetuneBtn.addEventListener('click', finetuneMarkedStations);
			
			// Load saved marks from localStorage
			loadMarkedStations();
		}
		
		function updateSpeedDisplay() {
			const ms = parseInt(elements.sweepSpeed.value);
			elements.sweepSpeedValue.textContent = (ms / 1000).toFixed(1) + 's';
		}
		
		async function toggleSweep() {
			if (sweepRunning) {
				// Stop sweep
				sweepAbort = true;
				elements.sweepStartBtn.textContent = '‚ñ∂Ô∏è Start Sweep';
				elements.sweepStartBtn.classList.remove('sweeping');
				elements.sweepMarkBtn.disabled = true;
				elements.sweepStatus.textContent = 'Stoppet';
			} else {
				// Start sweep
				sweepRunning = true;
				sweepAbort = false;
				elements.sweepStartBtn.textContent = '‚èπÔ∏è Stopp';
				elements.sweepStartBtn.classList.add('sweeping');
				elements.sweepMarkBtn.disabled = false;
				
				await runSweep();
				
				sweepRunning = false;
				elements.sweepStartBtn.textContent = '‚ñ∂Ô∏è Start Sweep';
				elements.sweepStartBtn.classList.remove('sweeping');
				elements.sweepMarkBtn.disabled = true;
			}
		}
		
		async function runSweep() {
			const startFreq = 87.5;
			const endFreq = 108.0;
			const step = 0.1;
			const historySize = 10;  // Keep last 10 frequencies for latency compensation
			
			sweepHistory = [];
			currentSweepFreq = startFreq;
			
			elements.sweepStatus.textContent = 'Skanner...';
			
			for (let freq = startFreq; freq <= endFreq && !sweepAbort; freq += step) {
				currentSweepFreq = freq;
				const freqStr = freq.toFixed(1) + 'M';
				
				// Update progress
				const progress = ((freq - startFreq) / (endFreq - startFreq)) * 100;
				elements.sweepProgressBar.style.width = progress + '%';
				elements.sweepProgressText.textContent = freq.toFixed(1) + ' MHz';
				
				// Tune to frequency
				try {
					await fetch('/frequency/human/' + freqStr);
					
					// Wait for configured time
					const waitTime = parseInt(elements.sweepSpeed.value);
					await sleep(waitTime);
					
					// Get signal level
					const response = await fetch('/state');
					const data = await response.json();
					const signal = parseInt(data.s_level) || 0;
					
					// Add to history for latency compensation
					sweepHistory.push({ freq, signal, timestamp: Date.now() });
					if (sweepHistory.length > historySize) {
						sweepHistory.shift();
					}
					
				} catch (err) {
					console.error('Sweep error at ' + freqStr + ':', err);
				}
			}
			
			if (!sweepAbort) {
				elements.sweepStatus.textContent = 'Ferdig! ' + markedStations.length + ' stasjoner markert.';
				elements.sweepProgressBar.style.width = '100%';
				elements.sweepProgressText.textContent = 'Ferdig';
			}
		}
		
		function markCurrentFrequency() {
			// Use history to compensate for latency - find strongest signal in recent history
			let bestMark = null;
			
			if (sweepHistory.length > 0) {
				// Find the strongest signal in recent history
				bestMark = sweepHistory.reduce((best, current) => 
					current.signal > best.signal ? current : best
				);
			} else {
				// Fallback to current frequency
				bestMark = { freq: currentSweepFreq, signal: state.s_level };
			}
			
			// Check if already marked (within 0.2 MHz)
			const existing = markedStations.find(s => Math.abs(s.freq - bestMark.freq) < 0.2);
			if (existing) {
				elements.sweepStatus.textContent = `Allerede markert n√¶r ${bestMark.freq.toFixed(1)} MHz`;
				return;
			}
			
			// Add mark
			markedStations.push({
				freq: bestMark.freq,
				signal: bestMark.signal,
				timestamp: Date.now()
			});
			
			// Visual feedback
			elements.sweepMarkBtn.classList.add('marked');
			setTimeout(() => elements.sweepMarkBtn.classList.remove('marked'), 300);
			
			elements.sweepStatus.textContent = `Markert: ${bestMark.freq.toFixed(1)} MHz (signal: ${bestMark.signal})`;
			
			// Update UI
			updateMarkedStationsUI();
			saveMarkedStations();
		}
		
		function updateMarkedStationsUI() {
			elements.markedCount.textContent = markedStations.length;
			elements.clearMarksBtn.style.display = markedStations.length > 0 ? 'block' : 'none';
			elements.finetuneBtn.disabled = markedStations.length === 0;
			
			if (markedStations.length === 0) {
				elements.markedList.innerHTML = '<span class="no-marks">Ingen markeringer enn√•</span>';
				return;
			}
			
			// Sort by frequency
			const sorted = [...markedStations].sort((a, b) => a.freq - b.freq);
			
			elements.markedList.innerHTML = sorted.map((station, index) => `
				<div class="marked-item" data-freq="${station.freq}" data-index="${index}">
					<span class="freq">${station.freq.toFixed(1)}</span>
					<span class="signal">üì∂ ${station.signal || '?'}</span>
					<button class="remove-mark" data-freq="${station.freq}">√ó</button>
				</div>
			`).join('');
			
			// Add click handlers
			elements.markedList.querySelectorAll('.marked-item').forEach(item => {
				item.addEventListener('click', (e) => {
					if (e.target.classList.contains('remove-mark')) {
						const freq = parseFloat(e.target.dataset.freq);
						removeMarkedStation(freq);
					} else {
						const freq = item.dataset.freq;
						setFrequencyHuman(freq + 'M');
					}
				});
			});
		}
		
		function removeMarkedStation(freq) {
			markedStations = markedStations.filter(s => s.freq !== freq);
			updateMarkedStationsUI();
			saveMarkedStations();
		}
		
		function clearAllMarks() {
			if (confirm('Fjerne alle markeringer?')) {
				markedStations = [];
				updateMarkedStationsUI();
				saveMarkedStations();
			}
		}
		
		function saveMarkedStations() {
			localStorage.setItem('fm_marked_stations', JSON.stringify(markedStations));
		}
		
		function loadMarkedStations() {
			try {
				const saved = localStorage.getItem('fm_marked_stations');
				if (saved) {
					markedStations = JSON.parse(saved);
					updateMarkedStationsUI();
				}
			} catch (e) {
				console.error('Failed to load saved stations:', e);
			}
		}
		
		async function finetuneMarkedStations() {
			if (markedStations.length === 0) return;
			
			elements.finetuneBtn.disabled = true;
			elements.finetuneBtn.textContent = 'üéØ Finjusterer...';
			elements.sweepStatus.textContent = 'Finjusterer markerte stasjoner...';
			
			// Stop polling during fine-tune
			if (pollInterval) {
				clearInterval(pollInterval);
				pollInterval = null;
			}
			
			const fineTunedStations = [];
			
			for (let i = 0; i < markedStations.length; i++) {
				const mark = markedStations[i];
				elements.sweepStatus.textContent = `Finjusterer ${i + 1}/${markedStations.length}: ${mark.freq.toFixed(1)} MHz`;
				
				// Scan ¬±0.3 MHz around the mark in 0.05 MHz steps
				const scanStart = Math.max(87.5, mark.freq - 0.3);
				const scanEnd = Math.min(108.0, mark.freq + 0.3);
				const step = 0.05;
				
				let bestFreq = mark.freq;
				let bestSignal = 0;
				
				for (let freq = scanStart; freq <= scanEnd; freq += step) {
					try {
						await fetch('/frequency/human/' + freq.toFixed(2) + 'M');
						await sleep(150);
						
						// Take a few samples
						let totalSignal = 0;
						for (let s = 0; s < 3; s++) {
							const response = await fetch('/state');
							const data = await response.json();
							totalSignal += parseInt(data.s_level) || 0;
							await sleep(30);
						}
						const avgSignal = totalSignal / 3;
						
						if (avgSignal > bestSignal) {
							bestSignal = avgSignal;
							bestFreq = freq;
						}
					} catch (err) {
						console.error('Fine-tune error:', err);
					}
				}
				
				fineTunedStations.push({
					freq: Math.round(bestFreq * 10) / 10,  // Round to 0.1 MHz
					signal: Math.round(bestSignal),
					originalFreq: mark.freq
				});
			}
			
			// Update marked stations with fine-tuned frequencies
			markedStations = fineTunedStations.map(s => ({
				freq: s.freq,
				signal: s.signal,
				timestamp: Date.now()
			}));
			
			updateMarkedStationsUI();
			saveMarkedStations();
			
			elements.sweepStatus.textContent = `Ferdig! Finjusterte ${fineTunedStations.length} stasjoner.`;
			elements.finetuneBtn.textContent = 'üéØ Finjuster markerte stasjoner';
			elements.finetuneBtn.disabled = markedStations.length === 0;
			
			// Resume polling
			pollInterval = setInterval(fetchState, 500);
		}

		// ============ AUDIO PLAYER ============
		
		function setupAudioPlayer() {
			if (!elements.audioPlayer) return;

			if (elements.playBtn) {
				elements.playBtn.addEventListener('click', togglePlayback);
			}

			if (elements.liveBtn) {
				elements.liveBtn.addEventListener('click', goLive);
			}

			elements.audioPlayer.addEventListener('play', () => updatePlayerUI(true));
			elements.audioPlayer.addEventListener('pause', () => updatePlayerUI(false));
			elements.audioPlayer.addEventListener('ended', () => updatePlayerUI(false));
			elements.audioPlayer.addEventListener('error', () => {
				updatePlayerUI(false);
				showPlayerError();
			});
			elements.audioPlayer.addEventListener('waiting', () => showPlayerStatus('Laster...'));
			elements.audioPlayer.addEventListener('playing', () => showPlayerStatus('Spiller direkte'));
		}

		function togglePlayback() {
			if (!elements.audioPlayer) return;
			
			if (elements.audioPlayer.paused) {
				goLive();
			} else {
				elements.audioPlayer.pause();
			}
		}

		function goLive() {
			if (!elements.audioPlayer) return;
			
			const source = elements.audioPlayer.querySelector('source');
			if (source) {
				source.src = '/stream.mp3?t=' + Date.now();
				elements.audioPlayer.load();
			}
			
			elements.audioPlayer.play().catch(err => {
				console.error('Playback failed:', err);
				showPlayerError();
			});
		}

		function updatePlayerUI(playing) {
			if (elements.playBtn) {
				elements.playBtn.innerHTML = playing ? '‚èπÔ∏è Stopp' : '‚ñ∂Ô∏è Start lytting';
				elements.playBtn.classList.toggle('playing', playing);
			}
			
			if (elements.playerStatus) {
				elements.playerStatus.textContent = playing ? 'Spiller direkte' : 'Stoppet';
				elements.playerStatus.classList.toggle('playing', playing);
				elements.playerStatus.classList.remove('error');
			}
		}

		function showPlayerStatus(msg) {
			if (elements.playerStatus) {
				elements.playerStatus.textContent = msg;
			}
		}

		function showPlayerError() {
			if (elements.playerStatus) {
				elements.playerStatus.textContent = 'Feil ved avspilling';
				elements.playerStatus.classList.add('error');
			}
		}

		// ============ EVENT LISTENERS ============
		
		function setupEventListeners() {
			// Frequency adjustment buttons
			document.querySelectorAll('[data-tune]').forEach(btn => {
				btn.addEventListener('click', () => {
					const delta = parseFloat(btn.dataset.tune);
					adjustFrequency(delta);
				});
			});

			// Set frequency button
			const setFreqBtn = document.getElementById('set-freq-btn');
			if (setFreqBtn) {
				setFreqBtn.addEventListener('click', setFrequencyFromInput);
			}

			// Frequency input - enter key
			if (elements.freqInput) {
				elements.freqInput.addEventListener('keypress', (e) => {
					if (e.key === 'Enter') {
						setFrequencyFromInput();
					}
				});
			}

			// Modulation select
			if (elements.modSelect) {
				elements.modSelect.addEventListener('change', () => {
					setDemod(elements.modSelect.value);
				});
			}

			// Gain select
			if (elements.gainSelect) {
				elements.gainSelect.addEventListener('change', () => {
					const value = elements.gainSelect.value;
					if (value === 'auto') {
						setAutoGain();
					} else {
						setGain(parseInt(value));
					}
				});
			}

			// Autogain checkbox
			if (elements.autogainCheck) {
				elements.autogainCheck.addEventListener('change', () => {
					if (elements.autogainCheck.checked) {
						setAutoGain();
					} else if (gains.length > 0) {
						setGain(gains[0]);
					}
				});
			}

			// Preset buttons
			document.querySelectorAll('[data-preset]').forEach(btn => {
				btn.addEventListener('click', () => {
					const freq = btn.dataset.preset;
					setFrequencyHuman(freq);
				});
			});
		}

		// ============ API FUNCTIONS ============
		
		function fetchState() {
			fetch('/state')
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				})
				.catch(err => console.error('State fetch error:', err));
		}

		function fetchGainList() {
			fetch('/gain/list')
				.then(res => res.json())
				.then(data => {
					gains = data.gains || [];
					populateGainSelect();
				})
				.catch(err => console.error('Gain list fetch error:', err));
		}

		function setFrequencyHuman(freqStr) {
			fetch('/frequency/human/' + encodeURIComponent(freqStr))
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				});
		}

		function adjustFrequency(deltaMHz) {
			const currentMHz = state.freq_i / 1000000;
			const newMHz = currentMHz + deltaMHz;
			setFrequencyHuman(newMHz.toFixed(1) + 'M');
		}

		function setFrequencyFromInput() {
			if (elements.freqInput && elements.freqInput.value) {
				let val = elements.freqInput.value.trim();
				if (!val.toUpperCase().endsWith('M')) {
					val += 'M';
				}
				setFrequencyHuman(val);
				elements.freqInput.value = '';
			}
		}

		function setDemod(mod) {
			fetch('/demod/' + mod)
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				});
		}

		function setGain(gain) {
			fetch('/gain/human/' + gain)
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				});
		}

		function setAutoGain() {
			fetch('/gain/auto')
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				});
		}

		// ============ UI UPDATE ============
		
		function updateUI() {
			// Frequency display
			if (elements.freqDisplay) {
				const freqMHz = state.freq_s ? state.freq_s.replace('M', '') : '---';
				elements.freqDisplay.textContent = freqMHz;
			}

			// Signal meter
			if (elements.signalBar) {
				const level = Math.min(100, state.s_level || 0);
				elements.signalBar.style.width = level + '%';
			}
			if (elements.signalValue) {
				elements.signalValue.textContent = state.s_level || 0;
			}

			// Modulation select
			if (elements.modSelect && state.mod) {
				elements.modSelect.value = state.mod;
			}

			// Gain select
			if (elements.gainSelect && !state.autogain) {
				elements.gainSelect.value = state.gain;
			}

			// Autogain checkbox
			if (elements.autogainCheck) {
				elements.autogainCheck.checked = state.autogain;
			}
		}

		function populateGainSelect() {
			if (!elements.gainSelect) return;
			
			elements.gainSelect.innerHTML = '<option value="auto">Auto</option>';
			gains.forEach(g => {
				const option = document.createElement('option');
				option.value = g;
				option.textContent = g + ' dB';
				elements.gainSelect.appendChild(option);
			});
		}

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

	})();
	</script>
</body>
</html>

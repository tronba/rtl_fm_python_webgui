<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>FM Radio</title>
	<link rel="stylesheet" href="css/style.css">
	<style>
		/* Sweep Scanner Styles */
		.sweep-controls {
			display: flex;
			flex-direction: column;
			gap: 12px;
		}
		
		.sweep-btn-row {
			display: flex;
			gap: 8px;
		}
		
		.sweep-btn {
			flex: 1;
			padding: 14px 16px;
			font-size: 16px;
			font-weight: 600;
			border: none;
			border-radius: 8px;
			cursor: pointer;
			transition: all 0.2s;
		}
		
		.sweep-btn-start {
			background: linear-gradient(135deg, #4CAF50, #45a049);
			color: white;
		}
		
		.sweep-btn-start:hover {
			background: linear-gradient(135deg, #45a049, #3d8b40);
		}
		
		.sweep-btn-start.sweeping {
			background: linear-gradient(135deg, #f44336, #d32f2f);
		}
		
		.sweep-btn-mark {
			background: linear-gradient(135deg, #2196F3, #1976D2);
			color: white;
			font-size: 18px;
		}
		
		.sweep-btn-mark:hover {
			background: linear-gradient(135deg, #1976D2, #1565C0);
		}
		
		.sweep-btn-mark:disabled {
			background: #ccc;
			cursor: not-allowed;
		}
		
		.sweep-btn-mark.marked {
			background: linear-gradient(135deg, #4CAF50, #45a049);
			animation: pulse-mark 0.3s ease;
		}
		
		@keyframes pulse-mark {
			0% { transform: scale(1); }
			50% { transform: scale(1.05); }
			100% { transform: scale(1); }
		}
		
		.sweep-progress {
			margin-top: 8px;
		}
		
		.sweep-progress-bar-container {
			height: 24px;
			background: #e0e0e0;
			border-radius: 12px;
			overflow: hidden;
			position: relative;
		}
		
		.sweep-progress-bar {
			height: 100%;
			background: linear-gradient(90deg, #4CAF50, #8BC34A);
			transition: width 0.3s ease;
			border-radius: 12px;
		}
		
		.sweep-progress-text {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-weight: 600;
			color: #333;
			font-size: 14px;
		}
		
		/* Speed buttons */
		.speed-btn-group {
			display: flex;
			gap: 8px;
			margin-top: 8px;
		}
		
		.speed-btn {
			flex: 1;
			padding: 8px 12px;
			border: 2px solid #ddd;
			background: white;
			border-radius: 6px;
			cursor: pointer;
			font-size: 14px;
			transition: all 0.2s;
		}
		
		.speed-btn.active {
			border-color: #2196F3;
			background: #e3f2fd;
			color: #1565C0;
			font-weight: 600;
		}
		
		.speed-btn:hover:not(.active) {
			border-color: #90caf9;
			background: #f5f5f5;
		}
		
		/* Saved Channels */
		.channel-list {
			display: flex;
			flex-direction: column;
			gap: 8px;
		}
		
		.channel-item {
			display: flex;
			align-items: center;
			gap: 10px;
			background: linear-gradient(135deg, #e3f2fd, #bbdefb);
			border: 2px solid #1565C0;
			border-radius: 8px;
			padding: 10px 12px;
			cursor: pointer;
			transition: all 0.2s;
		}
		
		.channel-item:hover {
			background: linear-gradient(135deg, #bbdefb, #90caf9);
		}
		
		.channel-item.playing {
			background: linear-gradient(135deg, #9C27B0, #7B1FA2);
			border-color: #9C27B0;
		}
		
		.channel-item .freq {
			font-weight: 700;
			font-size: 18px;
			color: #0d47a1;
			min-width: 70px;
		}
		
		.channel-item.playing .freq {
			color: white;
		}
		
		.channel-item .name-input {
			flex: 1;
			border: 1px solid #90caf9;
			border-radius: 4px;
			padding: 4px 8px;
			font-size: 14px;
			background: rgba(255,255,255,0.8);
		}
		
		.channel-item.playing .name-input {
			background: rgba(255,255,255,0.2);
			border-color: rgba(255,255,255,0.5);
			color: white;
		}
		
		.channel-item.playing .name-input::placeholder {
			color: rgba(255,255,255,0.6);
		}
		
		.channel-item .signal {
			font-size: 12px;
			color: #1565C0;
			min-width: 40px;
			text-align: right;
		}
		
		.channel-item.playing .signal {
			color: rgba(255,255,255,0.9);
		}
		
		.channel-item .remove-btn {
			width: 24px;
			height: 24px;
			background: #f44336;
			color: white;
			border: none;
			border-radius: 50%;
			font-size: 14px;
			cursor: pointer;
			display: flex;
			align-items: center;
			justify-content: center;
			opacity: 0.7;
			transition: opacity 0.2s;
		}
		
		.channel-item .remove-btn:hover {
			opacity: 1;
		}
		
		.channel-item.disabled {
			background: linear-gradient(135deg, #e0e0e0, #ccc);
			border-color: #999;
			pointer-events: none;
			opacity: 0.6;
		}
		
		.channel-item.disabled .freq {
			color: #666;
		}
		
		.no-channels {
			color: #999;
			font-style: italic;
			font-size: 14px;
			text-align: center;
			padding: 20px;
		}
		
		.channel-actions {
			display: flex;
			gap: 8px;
			margin-top: 12px;
		}
		
		.channel-actions button {
			flex: 1;
			padding: 10px;
			border: none;
			border-radius: 6px;
			cursor: pointer;
			font-size: 14px;
			font-weight: 500;
		}
		
		.save-btn {
			background: #4CAF50;
			color: white;
		}
		
		.save-btn:hover {
			background: #45a049;
		}
		
		.clear-btn {
			background: #f44336;
			color: white;
		}
		
		.clear-btn:hover {
			background: #d32f2f;
		}
		
		/* Manual Tuning */
		.manual-tuning-container {
			display: flex;
			flex-direction: column;
			gap: 8px;
			align-items: center;
		}
		
		.manual-tuning-input-row {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 6px;
		}
		
		.manual-tuning-buttons-row {
			display: flex;
			align-items: center;
			justify-content: center;
			gap: 6px;
			max-width: 400px;
			width: 100%;
		}
		
		.manual-tuning-buttons-row .tune-btn {
			flex: 1;
			min-width: 40px;
			max-width: 60px;
			height: 44px;
			font-size: 14px;
			font-weight: bold;
			border: none;
			border-radius: 8px;
			background: linear-gradient(135deg, #607D8B, #546E7A);
			color: white;
			cursor: pointer;
		}
		
		.manual-tuning-buttons-row .tune-btn:hover {
			background: linear-gradient(135deg, #546E7A, #455A64);
		}
		
		.manual-tuning-buttons-row .tune-btn.small {
			flex: 0.8;
			max-width: 50px;
		}
		
		.manual-tuning-input-row .freq-input {
			width: 80px;
			max-width: 80px;
			flex-grow: 0;
			flex-shrink: 0;
			text-align: center;
			font-size: 16px;
			padding: 10px 8px;
			border: 2px solid #ddd;
			border-radius: 8px;
		}
		
		.manual-tuning-input-row .freq-input:focus {
			border-color: #2196F3;
			outline: none;
		}
		
		.manual-tuning-input-row .enter-btn {
			padding: 10px 12px;
			background: linear-gradient(135deg, #4CAF50, #45a049);
			color: white;
			border: none;
			border-radius: 8px;
			font-size: 14px;
			font-weight: bold;
			cursor: pointer;
		}
		
		.manual-tuning-input-row .enter-btn:hover {
			background: linear-gradient(135deg, #45a049, #388E3C);
		}
		
		.manual-tuning-input-row .save-text-btn {
			padding: 10px 14px;
			background: linear-gradient(135deg, #2196F3, #1976D2);
			color: white;
			border: none;
			border-radius: 8px;
			font-size: 14px;
			font-weight: bold;
			cursor: pointer;
		}
		
		.manual-tuning-input-row .save-text-btn:hover {
			background: linear-gradient(135deg, #1976D2, #1565C0);
		}
		
		/* Centered Signal Meter */
		.signal-meter-container {
			margin: 16px 0;
			text-align: center;
		}
		
		.signal-meter {
			position: relative;
			height: 32px;
			background: var(--bg-card, #1f2937);
			border-radius: 16px;
			overflow: hidden;
		}
		
		.signal-meter-fill {
			position: absolute;
			top: 0;
			height: 100%;
			left: 50%;
			width: 0%;
			background: linear-gradient(90deg, #FFEB3B, #8BC34A, #4CAF50);
			transition: width 0.3s ease;
			border-radius: 0 16px 16px 0;
		}
		
		.signal-meter-fill-left {
			position: absolute;
			top: 0;
			height: 100%;
			right: 50%;
			width: 0%;
			background: linear-gradient(270deg, #FFEB3B, #8BC34A, #4CAF50);
			transition: width 0.3s ease;
			border-radius: 16px 0 0 16px;
		}
		
		.signal-value-overlay {
			position: absolute;
			top: 50%;
			left: 50%;
			transform: translate(-50%, -50%);
			font-size: 14px;
			font-weight: 700;
			color: #333;
			z-index: 3;
			text-shadow: 0 0 3px white, 0 0 3px white;
		}
		
		.status-text {
			font-size: 14px;
			color: #666;
			margin-top: 4px;
			min-height: 20px;
		}
		
		/* Progress bar in header */
		.header-progress {
			display: none;
			margin-top: 12px;
		}
		
		.header-progress.active {
			display: block;
		}
		
		.header-progress-bar {
			height: 8px;
			background: #e0e0e0;
			border-radius: 4px;
			overflow: hidden;
		}
		
		.header-progress-bar-fill {
			height: 100%;
			background: linear-gradient(90deg, #ff9800, #ffc107);
			transition: width 0.3s ease;
			border-radius: 4px;
		}
	</style>
</head>
<body>
	<a href="index.html" class="back-btn">‚Üê Back</a>

	<div class="header">
		<h1>üìª FM Radio</h1>
		<p class="subtitle">87.5 - 108 MHz</p>
	</div>

	<!-- Frequency Display -->
	<div class="card frequency-display">
		<div>
			<span class="frequency-value" id="freq-display">---</span>
			<span class="frequency-unit">MHz</span>
		</div>
		<div class="signal-meter-container">
			<div class="signal-meter">
				<div class="signal-meter-fill-left" id="signal-bar-left"></div>
				<div class="signal-meter-fill" id="signal-bar-right"></div>
				<div class="signal-value-overlay" id="signal-value">0</div>
			</div>
		</div>
		<div class="status-text" id="status-text">Ready</div>
		<div class="header-progress" id="header-progress">
			<div class="header-progress-bar">
				<div class="header-progress-bar-fill" id="header-progress-fill" style="width: 0%"></div>
			</div>
		</div>
	</div>

	<!-- Sweep Scanner -->
	<div class="card">
		<div class="card-title">üîç Sweep Scanner</div>
		<p style="font-size: 13px; color: #666; margin-bottom: 12px;">
			Listen as the scanner sweeps the band. Press "Mark" when you hear a station.
		</p>
		
		<div class="sweep-controls">
			<div class="sweep-btn-row">
				<button class="sweep-btn sweep-btn-start" id="sweep-start-btn">‚ñ∂Ô∏è Start Sweep</button>
				<button class="sweep-btn sweep-btn-mark" id="sweep-mark-btn" disabled>‚≠ê Mark</button>
			</div>
			
			<div class="speed-btn-group">
				<button class="speed-btn" data-speed="1500">Slow</button>
				<button class="speed-btn active" data-speed="600">Fast</button>
				<button class="speed-btn" data-speed="300">Turbo</button>
			</div>
		</div>
	</div>

	<!-- Saved Channels -->
	<div class="card">
		<div class="card-title">üìª Channels</div>
		<div class="channel-list" id="channel-list">
			<div class="no-channels">No channels saved yet. Run a sweep to find stations!</div>
		</div>
		<div class="channel-actions" id="channel-actions" style="display: none;">
			<button class="clear-btn" id="clear-channels-btn">üóëÔ∏è Clear All</button>
		</div>
	</div>

	<!-- Manual Tuning -->
	<div class="card">
		<div class="card-title">üéõÔ∏è Manual Tuning</div>
		<div class="manual-tuning-container">
			<div class="manual-tuning-input-row">
				<input type="text" class="freq-input" id="freq-input" placeholder="99.5">
				<button class="enter-btn" id="freq-enter-btn">Go</button>
				<button class="save-text-btn" id="manual-save-btn">Save</button>
			</div>
			<div class="manual-tuning-buttons-row">
				<button class="tune-btn small" data-tune="-1">‚àí1</button>
				<button class="tune-btn small" data-tune="-0.5">‚àí.5</button>
				<button class="tune-btn" data-tune="-0.1">‚àí.1</button>
				<button class="tune-btn" data-tune="0.1">+.1</button>
				<button class="tune-btn small" data-tune="0.5">+.5</button>
				<button class="tune-btn small" data-tune="1">+1</button>
			</div>
		</div>
	</div>

	<!-- Settings -->
	<div class="card">
		<div class="card-title">‚öôÔ∏è Settings</div>
		<div class="settings-row">
			<div class="setting-group">
				<label>Modulation</label>
				<select id="mod-select">
					<option value="w">WBFM (Stereo)</option>
					<option value="f">FM (Mono)</option>
				</select>
			</div>
			<div class="setting-group">
				<label>Gain</label>
				<select id="gain-select">
					<option value="auto">Auto</option>
				</select>
			</div>
		</div>
		<div class="checkbox-group">
			<input type="checkbox" id="autogain-check" checked>
			<label for="autogain-check">Automatic gain control</label>
		</div>
	</div>

	<!-- Audio Player -->
	<div class="audio-player">
		<div class="player-controls">
			<button class="player-btn player-btn-play" id="player-btn-play">‚ñ∂Ô∏è Start Listening</button>
			<button class="player-btn player-btn-live" id="player-btn-live"><span class="live-dot"></span> Sync</button>
		</div>
		<div class="player-status" id="player-status">Press Start to listen</div>
		<audio id="audio-player" preload="none">
			<source src="/stream.mp3" type="audio/mpeg">
		</audio>
	</div>

	<script>
	/**
	 * FM Sweep Scanner - Hybrid Manual/Auto Station Finding
	 */
	(function() {
		'use strict';

		// State
		let state = {
			freq_i: 0,
			freq_s: '---',
			s_level: 0,
			mod: 'w',
			gain: 0,
			autogain: true
		};
		let gains = [];
		let pollInterval = null;
		
		// Sweep scanner state
		let sweepRunning = false;
		let sweepAbort = false;
		let fineTuning = false;
		let fineTuneAbort = false;
		let currentSweepFreq = 87.5;
		let sweepSpeed = 600;  // ms per step (Fast default)
		let markedStations = [];  // Array of {freq, signal, name}
		let sweepHistory = [];    // Last N frequencies for latency compensation
		let currentPlayingFreq = null;
		let channelsDisabled = false;  // Gray out channels during sweep/finetune

		// DOM Elements
		let elements = {};

		document.addEventListener('DOMContentLoaded', init);

		function init() {
			elements = {
				freqDisplay: document.getElementById('freq-display'),
				freqInput: document.getElementById('freq-input'),
				signalBarLeft: document.getElementById('signal-bar-left'),
				signalBarRight: document.getElementById('signal-bar-right'),
				signalValue: document.getElementById('signal-value'),
				statusText: document.getElementById('status-text'),
				headerProgress: document.getElementById('header-progress'),
				headerProgressFill: document.getElementById('header-progress-fill'),
				modSelect: document.getElementById('mod-select'),
				gainSelect: document.getElementById('gain-select'),
				autogainCheck: document.getElementById('autogain-check'),
				audioPlayer: document.getElementById('audio-player'),
				playBtn: document.getElementById('player-btn-play'),
				liveBtn: document.getElementById('player-btn-live'),
				playerStatus: document.getElementById('player-status'),
				// Sweep elements
				sweepStartBtn: document.getElementById('sweep-start-btn'),
				sweepMarkBtn: document.getElementById('sweep-mark-btn'),
				// Channel elements
				channelList: document.getElementById('channel-list'),
				channelActions: document.getElementById('channel-actions'),
				clearChannelsBtn: document.getElementById('clear-channels-btn'),
				// Manual tuning
				manualSaveBtn: document.getElementById('manual-save-btn'),
				freqEnterBtn: document.getElementById('freq-enter-btn')
			};

			setupEventListeners();
			setupSweepScanner();
			setupAudioPlayer();
			fetchGainList();
			fetchState();
			pollInterval = setInterval(fetchState, 500);
			
			// Load saved channels
			loadSavedChannels();
		}

		// ============ SWEEP SCANNER ============
		
		function setupSweepScanner() {
			// Start/Stop button
			elements.sweepStartBtn.addEventListener('click', toggleSweep);
			
			// Mark button
			elements.sweepMarkBtn.addEventListener('click', markCurrentFrequency);
			
			// Speed buttons
			document.querySelectorAll('.speed-btn').forEach(btn => {
				btn.addEventListener('click', () => {
					document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
					btn.classList.add('active');
					sweepSpeed = parseInt(btn.dataset.speed);
				});
			});
			
			// Clear button
			elements.clearChannelsBtn.addEventListener('click', clearAllChannels);
		}
		
		async function toggleSweep() {
			if (fineTuning) {
				// Stop fine-tuning completely
				fineTuneAbort = true;
				channelsDisabled = false;
				elements.sweepStartBtn.textContent = '‚ñ∂Ô∏è Start Sweep';
				elements.sweepStartBtn.classList.remove('sweeping');
				elements.sweepMarkBtn.disabled = true;
				elements.headerProgress.classList.remove('active');
				setStatus('Fine-tuning stopped');
				updateChannelListUI();
			} else if (sweepRunning) {
				// Stop sweep but proceed to fine-tune
				sweepAbort = true;
				setStatus('Stopping sweep, will fine-tune marked stations...');
			} else {
				// Clear current marks for fresh sweep
				markedStations = [];
				channelsDisabled = true;
				updateChannelListUI();
				
				// Show header progress
				elements.headerProgress.classList.add('active');
				elements.headerProgressFill.style.width = '0%';
				
				// Start audio and sync first
				setStatus('Starting audio...');
				await startAudioAndSync();
				
				// Start sweep
				sweepRunning = true;
				sweepAbort = false;
				elements.sweepStartBtn.textContent = '‚èπÔ∏è Stop';
				elements.sweepStartBtn.classList.add('sweeping');
				elements.sweepMarkBtn.disabled = false;
				
				await runSweep();
				
				sweepRunning = false;
				channelsDisabled = false;
				elements.sweepStartBtn.textContent = '‚ñ∂Ô∏è Start Sweep';
				elements.sweepStartBtn.classList.remove('sweeping');
				elements.sweepMarkBtn.disabled = true;
				elements.headerProgress.classList.remove('active');
				updateChannelListUI();
			}
		}
		
		async function startAudioAndSync() {
			if (!elements.audioPlayer) return;
			
			// First tune to start frequency BEFORE starting audio
			setStatus('Tuning to 87.5 MHz...');
			await fetch('/frequency/human/87.5M');
			await sleep(300);
			
			// Now start fresh stream from current frequency
			setStatus('Starting audio...');
			const source = elements.audioPlayer.querySelector('source');
			if (source) {
				source.src = '/stream.mp3?t=' + Date.now();
				elements.audioPlayer.load();
			}
			
			try {
				await elements.audioPlayer.play();
				updatePlayerUI(true);
				// Wait longer for audio to buffer properly
				setStatus('Buffering audio...');
				await sleep(1500);
			} catch (err) {
				console.error('Audio start failed:', err);
			}
		}
		
		async function syncAudio() {
			if (!elements.audioPlayer) return;
			
			const source = elements.audioPlayer.querySelector('source');
			if (source) {
				source.src = '/stream.mp3?t=' + Date.now();
				elements.audioPlayer.load();
			}
			
			try {
				await elements.audioPlayer.play();
				updatePlayerUI(true);
			} catch (err) {
				console.error('Audio sync failed:', err);
			}
		}
		
		async function runSweep() {
			const startFreq = 87.5;
			const endFreq = 108.0;
			const step = 0.1;
			const historySize = 10;
			
			sweepHistory = [];
			currentSweepFreq = startFreq;
			
			setStatus('Scanning...');
			
			// Initial delay to let audio settle before sweep starts
			await sleep(1000);
			
			for (let freq = startFreq; freq <= endFreq && !sweepAbort; freq += step) {
				currentSweepFreq = freq;
				const freqStr = freq.toFixed(1) + 'M';
				
				// Update progress in header
				const progress = ((freq - startFreq) / (endFreq - startFreq)) * 100;
				elements.headerProgressFill.style.width = progress + '%';
				
				try {
					await fetch('/frequency/human/' + freqStr);
					await sleep(sweepSpeed);
					
					const response = await fetch('/state');
					const data = await response.json();
					const signal = parseInt(data.s_level) || 0;
					
					sweepHistory.push({ freq, signal, timestamp: Date.now() });
					if (sweepHistory.length > historySize) {
						sweepHistory.shift();
					}
					
				} catch (err) {
					console.error('Sweep error at ' + freqStr + ':', err);
				}
			}
			
			elements.headerProgressFill.style.width = '100%';
			
			if (markedStations.length > 0) {
				setStatus(`${markedStations.length} marked - fine-tuning...`);
				// Gray out mark button during fine-tune
				elements.sweepMarkBtn.disabled = true;
				fineTuning = true;
				fineTuneAbort = false;
				await finetuneMarkedStations();
				fineTuning = false;
				
				if (!fineTuneAbort) {
					setStatus(`Done! ${markedStations.length} stations found.`);
				}
			} else {
				setStatus('Done - no stations marked.');
			}
		}
		
		function markCurrentFrequency() {
			let bestMark = null;
			
			if (sweepHistory.length > 0) {
				bestMark = sweepHistory.reduce((best, current) => 
					current.signal > best.signal ? current : best
				);
			} else {
				bestMark = { freq: currentSweepFreq, signal: state.s_level };
			}
			
			// Check if already marked (within 0.2 MHz)
			const existing = markedStations.find(s => Math.abs(s.freq - bestMark.freq) < 0.2);
			if (existing) {
				setStatus(`Already marked near ${bestMark.freq.toFixed(1)} MHz`);
				return;
			}
			
			markedStations.push({
				freq: bestMark.freq,
				signal: bestMark.signal,
				name: ''
			});
			
			// Visual feedback
			elements.sweepMarkBtn.classList.add('marked');
			setTimeout(() => elements.sweepMarkBtn.classList.remove('marked'), 300);
			
			setStatus(`Marked: ${bestMark.freq.toFixed(1)} MHz (signal: ${bestMark.signal})`);
			updateChannelListUI();
		}
		
		async function finetuneMarkedStations() {
			const fineTunedStations = [];
			
			for (let i = 0; i < markedStations.length && !fineTuneAbort; i++) {
				const mark = markedStations[i];
				setStatus(`Fine-tuning ${i + 1}/${markedStations.length}: ${mark.freq.toFixed(1)} MHz`);
				
				const scanStart = Math.max(87.5, mark.freq - 0.3);
				const scanEnd = Math.min(108.0, mark.freq + 0.3);
				const step = 0.05;
				
				let bestFreq = mark.freq;
				let bestSignal = 0;
				
				for (let freq = scanStart; freq <= scanEnd && !fineTuneAbort; freq += step) {
					try {
						await fetch('/frequency/human/' + freq.toFixed(2) + 'M');
						
						// Update frequency display during fine-tune
						if (elements.freqDisplay) {
							elements.freqDisplay.textContent = freq.toFixed(1);
						}
						
						await sleep(150);
						
						let totalSignal = 0;
						for (let s = 0; s < 3; s++) {
							const response = await fetch('/state');
							const data = await response.json();
							totalSignal += parseInt(data.s_level) || 0;
							await sleep(30);
						}
						const avgSignal = totalSignal / 3;
						
						if (avgSignal > bestSignal) {
							bestSignal = avgSignal;
							bestFreq = freq;
						}
					} catch (err) {
						console.error('Fine-tune error:', err);
					}
				}
				
				// Round to 0.1 MHz
				const roundedFreq = Math.round(bestFreq * 10) / 10;
				
				// Only add if not already in fineTunedStations (deduplication fix)
				const alreadyExists = fineTunedStations.find(s => s.freq === roundedFreq);
				if (!alreadyExists) {
					fineTunedStations.push({
						freq: roundedFreq,
						signal: Math.round(bestSignal),
						name: mark.name || ''
					});
				}
			}
			
			markedStations = fineTunedStations;
			updateChannelListUI();
		}
		
		function updateChannelListUI() {
			const hasChannels = markedStations.length > 0;
			elements.channelActions.style.display = hasChannels ? 'flex' : 'none';
			
			if (!hasChannels) {
				elements.channelList.innerHTML = '<div class="no-channels">No channels saved yet. Run a sweep to find stations!</div>';
				return;
			}
			
			// Sort by frequency
			const sorted = [...markedStations].sort((a, b) => a.freq - b.freq);
			
			elements.channelList.innerHTML = sorted.map((station, index) => {
				const isPlaying = currentPlayingFreq === station.freq;
				const disabledClass = channelsDisabled ? 'disabled' : '';
				return `
				<div class="channel-item ${isPlaying ? 'playing' : ''} ${disabledClass}" data-freq="${station.freq}">
					<span class="freq">${station.freq.toFixed(1)}</span>
					<input type="text" class="name-input" placeholder="Station name" 
						value="${station.name || ''}" data-freq="${station.freq}" ${channelsDisabled ? 'disabled' : ''}>
					<span class="signal">üì∂${station.signal || '?'}</span>
					<button class="remove-btn" data-freq="${station.freq}" ${channelsDisabled ? 'disabled' : ''}>√ó</button>
				</div>
			`}).join('');
			
			// Add click handlers (only when not disabled)
			if (!channelsDisabled) {
				elements.channelList.querySelectorAll('.channel-item').forEach(item => {
					item.addEventListener('click', async (e) => {
						// Don't trigger if clicking input or remove button
						if (e.target.classList.contains('name-input') || e.target.classList.contains('remove-btn')) {
							return;
						}
						const freq = parseFloat(item.dataset.freq);
						await tuneToChannel(freq);
					});
				});
			}
			
			// Name input handlers
			elements.channelList.querySelectorAll('.name-input').forEach(input => {
				input.addEventListener('change', (e) => {
					const freq = parseFloat(e.target.dataset.freq);
					const station = markedStations.find(s => s.freq === freq);
					if (station) {
						station.name = e.target.value;
					}
				});
				// Prevent click from bubbling to channel item
				input.addEventListener('click', (e) => e.stopPropagation());
			});
			
			// Remove button handlers
			elements.channelList.querySelectorAll('.remove-btn').forEach(btn => {
				btn.addEventListener('click', (e) => {
					e.stopPropagation();
					const freq = parseFloat(btn.dataset.freq);
					removeChannel(freq);
				});
			});
		}
		
		async function tuneToChannel(freq) {
			currentPlayingFreq = freq;
			updateChannelListUI();
			setStatus(`Tuning to ${freq.toFixed(1)} MHz...`);
			
			await fetch('/frequency/human/' + freq.toFixed(1) + 'M');
			await syncAudio();
			
			setStatus(`Playing ${freq.toFixed(1)} MHz`);
		}
		
		function removeChannel(freq) {
			markedStations = markedStations.filter(s => s.freq !== freq);
			if (currentPlayingFreq === freq) {
				currentPlayingFreq = null;
			}
			updateChannelListUI();
		}
		
		function clearAllChannels() {
			if (confirm('Remove all channels?')) {
				markedStations = [];
				currentPlayingFreq = null;
				localStorage.removeItem('fm_saved_channels');
				updateChannelListUI();
				setStatus('Channels cleared');
			}
		}
		
		function saveChannelsToStorage() {
			localStorage.setItem('fm_saved_channels', JSON.stringify(markedStations));
			setStatus(`${markedStations.length} channels saved!`);
		}
		
		function addCurrentFrequencyToChannels() {
			const currentMHz = state.freq_i / 1000000;
			const roundedFreq = Math.round(currentMHz * 10) / 10;
			
			// Check if we have a currently playing channel and are within 1 MHz of it
			if (currentPlayingFreq !== null) {
				const distanceFromPlaying = Math.abs(roundedFreq - currentPlayingFreq);
				
				if (distanceFromPlaying < 1.0) {
					// Update the existing channel instead of creating new
					const existingStation = markedStations.find(s => s.freq === currentPlayingFreq);
					if (existingStation) {
						const oldFreq = existingStation.freq;
						existingStation.freq = roundedFreq;
						existingStation.signal = state.s_level || 0;
						
						// Update currentPlayingFreq to new frequency
						currentPlayingFreq = roundedFreq;
						
						// Re-sort by frequency
						markedStations.sort((a, b) => a.freq - b.freq);
						
						updateChannelListUI();
						saveChannelsToStorage();
						setStatus(`Updated ${oldFreq.toFixed(1)} ‚Üí ${roundedFreq.toFixed(1)} MHz`);
						return;
					}
				}
			}
			
			// Check if already exists at exact frequency
			const exists = markedStations.some(s => Math.abs(s.freq - roundedFreq) < 0.05);
			if (exists) {
				setStatus(`${roundedFreq.toFixed(1)} MHz already in channels`);
				return;
			}
			
			// Prompt for name
			const name = prompt(`Name for ${roundedFreq.toFixed(1)} MHz:`, '');
			
			markedStations.push({
				freq: roundedFreq,
				signal: state.s_level || 0,
				name: name || ''
			});
			
			// Sort by frequency
			markedStations.sort((a, b) => a.freq - b.freq);
			
			updateChannelListUI();
			saveChannelsToStorage();
			setStatus(`Added ${roundedFreq.toFixed(1)} MHz to channels`);
		}
		
		function loadSavedChannels() {
			try {
				const saved = localStorage.getItem('fm_saved_channels');
				if (saved) {
					markedStations = JSON.parse(saved);
					updateChannelListUI();
					if (markedStations.length > 0) {
						setStatus(`${markedStations.length} saved channels loaded`);
					}
				}
			} catch (e) {
				console.error('Failed to load saved channels:', e);
			}
		}
		
		function setStatus(text) {
			if (elements.statusText) {
				elements.statusText.textContent = text;
			}
		}

		// ============ AUDIO PLAYER ============
		
		function setupAudioPlayer() {
			if (!elements.audioPlayer) return;

			if (elements.playBtn) {
				elements.playBtn.addEventListener('click', togglePlayback);
			}

			if (elements.liveBtn) {
				elements.liveBtn.addEventListener('click', syncAudio);
			}

			elements.audioPlayer.addEventListener('play', () => updatePlayerUI(true));
			elements.audioPlayer.addEventListener('pause', () => updatePlayerUI(false));
			elements.audioPlayer.addEventListener('ended', () => updatePlayerUI(false));
			elements.audioPlayer.addEventListener('error', () => {
				updatePlayerUI(false);
				showPlayerError();
			});
			elements.audioPlayer.addEventListener('waiting', () => showPlayerStatus('Loading...'));
			elements.audioPlayer.addEventListener('playing', () => showPlayerStatus('Playing live'));
		}

		function togglePlayback() {
			if (!elements.audioPlayer) return;
			
			if (elements.audioPlayer.paused) {
				syncAudio();
			} else {
				elements.audioPlayer.pause();
			}
		}

		function updatePlayerUI(playing) {
			if (elements.playBtn) {
				elements.playBtn.innerHTML = playing ? '‚èπÔ∏è Stop' : '‚ñ∂Ô∏è Start Listening';
				elements.playBtn.classList.toggle('playing', playing);
			}
			
			if (elements.playerStatus) {
				elements.playerStatus.textContent = playing ? 'Playing live' : 'Stopped';
				elements.playerStatus.classList.toggle('playing', playing);
				elements.playerStatus.classList.remove('error');
			}
		}

		function showPlayerStatus(msg) {
			if (elements.playerStatus) {
				elements.playerStatus.textContent = msg;
			}
		}

		function showPlayerError() {
			if (elements.playerStatus) {
				elements.playerStatus.textContent = 'Playback error';
				elements.playerStatus.classList.add('error');
			}
		}

		// ============ EVENT LISTENERS ============
		
		function setupEventListeners() {
			// Manual tuning buttons with data-tune attribute
			document.querySelectorAll('[data-tune]').forEach(btn => {
				btn.addEventListener('click', () => {
					const delta = parseFloat(btn.getAttribute('data-tune'));
					adjustFrequency(delta);
				});
			});
			
			// Manual save button
			if (elements.manualSaveBtn) {
				elements.manualSaveBtn.addEventListener('click', () => {
					addCurrentFrequencyToChannels();
				});
			}

			// Frequency input - enter key or blur
			if (elements.freqInput) {
				elements.freqInput.addEventListener('keypress', (e) => {
					if (e.key === 'Enter') {
						setFrequencyFromInput();
					}
				});
			}
			
			// Go button for frequency input
			if (elements.freqEnterBtn) {
				elements.freqEnterBtn.addEventListener('click', () => {
					setFrequencyFromInput();
				});
			}

			// Modulation select
			if (elements.modSelect) {
				elements.modSelect.addEventListener('change', () => {
					setDemod(elements.modSelect.value);
				});
			}

			// Gain select
			if (elements.gainSelect) {
				elements.gainSelect.addEventListener('change', () => {
					const value = elements.gainSelect.value;
					if (value === 'auto') {
						setAutoGain();
					} else {
						setGain(parseInt(value));
					}
				});
			}

			// Autogain checkbox
			if (elements.autogainCheck) {
				elements.autogainCheck.addEventListener('change', () => {
					if (elements.autogainCheck.checked) {
						setAutoGain();
					} else if (gains.length > 0) {
						setGain(gains[0]);
					}
				});
			}
		}

		// ============ API FUNCTIONS ============
		
		function fetchState() {
			fetch('/state')
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				})
				.catch(err => console.error('State fetch error:', err));
		}

		function fetchGainList() {
			fetch('/gain/list')
				.then(res => res.json())
				.then(data => {
					gains = data.gains || [];
					populateGainSelect();
				})
				.catch(err => console.error('Gain list fetch error:', err));
		}

		async function setFrequencyHuman(freqStr) {
			const response = await fetch('/frequency/human/' + encodeURIComponent(freqStr));
			const data = await response.json();
			state = data;
			updateUI();
		}

		function adjustFrequency(deltaMHz) {
			const currentMHz = state.freq_i / 1000000;
			const newMHz = currentMHz + deltaMHz;
			setFrequencyHuman(newMHz.toFixed(1) + 'M');
		}

		function setFrequencyFromInput() {
			if (elements.freqInput && elements.freqInput.value) {
				let val = elements.freqInput.value.trim();
				// Handle various input formats
				val = val.toUpperCase().replace('MHZ', '').replace('M', '').trim();
				const num = parseFloat(val);
				if (!isNaN(num) && num >= 87.5 && num <= 108) {
					setFrequencyHuman(num.toFixed(1) + 'M');
					elements.freqInput.value = '';
					elements.freqInput.placeholder = num.toFixed(1) + ' MHz';
				}
			}
		}

		function setDemod(mod) {
			fetch('/demod/' + mod)
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				});
		}

		function setGain(gain) {
			fetch('/gain/human/' + gain)
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				});
		}

		function setAutoGain() {
			fetch('/gain/auto')
				.then(res => res.json())
				.then(data => {
					state = data;
					updateUI();
				});
		}

		// ============ UI UPDATE ============
		
		function updateUI() {
			// Frequency display - show expected freq during sweep (accounting for audio latency)
			if (elements.freqDisplay) {
				let displayFreq;
				if (sweepRunning && sweepHistory.length > 0) {
					// Show the oldest frequency in history (what user is hearing)
					displayFreq = sweepHistory[0].freq.toFixed(1);
				} else {
					displayFreq = state.freq_s ? state.freq_s.replace('M', '') : '---';
				}
				elements.freqDisplay.textContent = displayFreq;
				
				// Also update the frequency input field
				if (elements.freqInput && displayFreq !== '---') {
					elements.freqInput.value = displayFreq;
				}
			}

			// Signal meter (dual bars expanding from center, max 700)
			if (elements.signalBarLeft && elements.signalBarRight) {
				const rawLevel = state.s_level || 0;
				const level = Math.min(100, (rawLevel / 700) * 100);
				// Each bar fills up to 50% (half the meter)
				const barWidth = level / 2;
				elements.signalBarLeft.style.width = barWidth + '%';
				elements.signalBarRight.style.width = barWidth + '%';
			}
			if (elements.signalValue) {
				elements.signalValue.textContent = state.s_level || 0;
			}

			// Modulation select
			if (elements.modSelect && state.mod) {
				elements.modSelect.value = state.mod;
			}

			// Gain select
			if (elements.gainSelect && !state.autogain) {
				elements.gainSelect.value = state.gain;
			}

			// Autogain checkbox
			if (elements.autogainCheck) {
				elements.autogainCheck.checked = state.autogain;
			}
		}

		function populateGainSelect() {
			if (!elements.gainSelect) return;
			
			elements.gainSelect.innerHTML = '<option value="auto">Auto</option>';
			gains.forEach(g => {
				const option = document.createElement('option');
				option.value = g;
				option.textContent = g + ' dB';
				elements.gainSelect.appendChild(option);
			});
		}

		function sleep(ms) {
			return new Promise(resolve => setTimeout(resolve, ms));
		}

	})();
	</script>
</body>
</html>
